# practice

코딩테스트 연습
이것이 취업을 위한 코딩 테스트 문제

# greedy algorithm

greedy algorithm 은 말그대로 단순하게, 탐욕적으로 문제를 푸는 알고리즘이다.
탐욕적이라는 것은 현 상황에서 가장 좋아보이는 것을 고르는 방법을 의미한다.
매 순간마다 가장 좋아보이는 것을 선택하고, 현재의 선택이 나중에 미치는 영향을 고려하지 않는다.

1. 거스름돈 문제
   카운터에서 거스름 돈으로 줄 때, 500, 100 , 50 ,10 원 동전으로 줄 때,
   동전의 개수가 무한하다고 가정할 때, 거슬러줘야 할 동전의 최소 개수를 구하라.

2. 큰 수의 법칙
   다양햔 수로 이루어진 배열이 있을 때 주어진 수를 m번 더해 가장 큰 수를 만들어야 한다.
   이 때, 특정 인덱스가 연속해서 k번을 초과하면 안된다.

가장 큰 수를 만드는 경우의 수는 배열 중의 가장 큰 수 (first)를 k번 더하고 두 번째로 큰 수(second)를 한 번만 더 할 때이다.
이를 반복해서 m번을 더할때가 가장 큰 수이다.
이 반복되는 수열은 k+1번마다 반복된다.
따라서 (first\*k+second)에 (m//(k+1)) 곱하고, first에 (m%(k+1))를 곱한 값이 수식이 된다.

수식 : max(큰 수)=quotient(몫)*(first*k+second)+first\*remainder(나머지)

3. 숫자 카드 게임
   1. 숫자가 쓰인 카드가 n\*m 형태로 놓여있다. n은 행의개수 m은 열의 개수이다.
   2. 먼저 뽑을려고 하는 카드의 행을 선택한다
   3. 그 행에 포함된 카드 중 가장 숫자가 낮은 카드를 뽑아야 한다.
   4. 따라서 행을 선택할 때, 해당 행에서 가장 숫자가 낮은 카드를 뽑을 것을 고려해 최종적으로 가장 높은 숫자의 카드를 뽑을 수 있도록 전략을 세워야 한다.

min 함수를 이용해서 각 행에서 가장 작은 값을 찾아 저장한 뒤에 그 중에서 가장 큰 수를 찾는다.

# Implementation <구현>

구현은 머리속에 있는 알고리즘을 소스코드로 구현하는 과정이다.
문제를 풀 때, 문제를 해결하는 알고리즘을 알아낼 수 있지만 코딩을 하는 과정에서 애를 먹는 경우가 있다.
구현 파트에서는 그런 경우를 고려해서 문제를 풀어보는 연습을 한다.
대게 이런 경우는 사소한 조건 설정이 많을 수록 까다로운 경향이 있다.

이럴 떄, 해결 방법은 크게 두 가지로 분류될 수 있다.
완전 탐색과 스뮬레이션이다. 완전 탐색은 모든 경우의 수를 주저 없이 다 계산하는 해결 방법이고, 시뮬레이션은 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행하는 방법이다. 이런 문제를 풀 경우에는 변수를 표현하는 범위를 고려하거나 메모리의 제한, 시간 제한에 신경써서 풀어야 한다.
