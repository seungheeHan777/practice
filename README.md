# practice

코딩테스트 연습
이것이 취업을 위한 코딩 테스트 문제

# greedy algorithm

greedy algorithm 은 말그대로 단순하게, 탐욕적으로 문제를 푸는 알고리즘이다.
탐욕적이라는 것은 현 상황에서 가장 좋아보이는 것을 고르는 방법을 의미한다.
매 순간마다 가장 좋아보이는 것을 선택하고, 현재의 선택이 나중에 미치는 영향을 고려하지 않는다.

1. 거스름돈 문제
   카운터에서 거스름 돈으로 줄 때, 500, 100 , 50 ,10 원 동전으로 줄 때,
   동전의 개수가 무한하다고 가정할 때, 거슬러줘야 할 동전의 최소 개수를 구하라.

2. 큰 수의 법칙
   다양햔 수로 이루어진 배열이 있을 때 주어진 수를 m번 더해 가장 큰 수를 만들어야 한다.
   이 때, 특정 인덱스가 연속해서 k번을 초과하면 안된다.

가장 큰 수를 만드는 경우의 수는 배열 중의 가장 큰 수 (first)를 k번 더하고 두 번째로 큰 수(second)를 한 번만 더 할 때이다.
이를 반복해서 m번을 더할때가 가장 큰 수이다.
이 반복되는 수열은 k+1번마다 반복된다.
따라서 (first\*k+second)에 (m//(k+1)) 곱하고, first에 (m%(k+1))를 곱한 값이 수식이 된다.

수식 : max(큰 수)=quotient(몫)*(first*k+second)+first\*remainder(나머지)

3. 숫자 카드 게임
   1. 숫자가 쓰인 카드가 n\*m 형태로 놓여있다. n은 행의개수 m은 열의 개수이다.
   2. 먼저 뽑을려고 하는 카드의 행을 선택한다
   3. 그 행에 포함된 카드 중 가장 숫자가 낮은 카드를 뽑아야 한다.
   4. 따라서 행을 선택할 때, 해당 행에서 가장 숫자가 낮은 카드를 뽑을 것을 고려해 최종적으로 가장 높은 숫자의 카드를 뽑을 수 있도록 전략을 세워야 한다.

min 함수를 이용해서 각 행에서 가장 작은 값을 찾아 저장한 뒤에 그 중에서 가장 큰 수를 찾는다.

# Implementation <구현>

구현은 머리속에 있는 알고리즘을 소스코드로 구현하는 과정이다.
문제를 풀 때, 문제를 해결하는 알고리즘을 알아낼 수 있지만 코딩을 하는 과정에서 애를 먹는 경우가 있다.
구현 파트에서는 그런 경우를 고려해서 문제를 풀어보는 연습을 한다.
대게 이런 경우는 사소한 조건 설정이 많을 수록 까다로운 경향이 있다.

이럴 떄, 해결 방법은 크게 두 가지로 분류될 수 있다.
완전 탐색과 스뮬레이션이다. 완전 탐색은 모든 경우의 수를 주저 없이 다 계산하는 해결 방법이고, 시뮬레이션은 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행하는 방법이다. 이런 문제를 풀 경우에는 변수를 표현하는 범위를 고려하거나 메모리의 제한, 시간 제한에 신경써서 풀어야 한다.

1. 상하좌우

   - n\*n 크기의 맵이 있을 때, 왼쪽 위 좌표는 (1,1), 오른쪽 아래 좌표는 (n,n)이다. 이때, a가 맵 위에서 움직일 때, L,R,U,D를 이용해서 a를 이동시킬 수 있다. a가 맵 밖을 벗어나는 움직임을 입력하면 그 움직임은 무시가 된다. 이 때, 이동키를 입력해서 a가 최종적으로 도착하는 좌표를 구하라.

   - 입력 조건
     - 첫째 줄에 공간의 크기를 나타내는 n이 주어짐. (1<=n<=100)
     - 둘째 줄에 a가 이동할 계획서 내용이 주어짐 (1<=이동 횟수<=100)
   - 출력 조건
     - 첫째 줄에 a가 최종적으로 도착할 좌표 x,y를 공백으로 구분해서 출력한다.

   이 문제의 연산 횟수는 이동 횟수에 비례한다. 이동 횟수를 n번이라고 할 경우에 시간 복잡도는 O(N)이다. 따라서 이 문제의 경우 시간 복잡도는 매우 넉넉한 편이다.
   이 문제는 일련의 명령에 따라 개체를 이동시킨다는 점에서 시뮬레이션 유형으로 분류된다. 다만 다른 곳에서는 다르게 분류할 수 도 있다.

2. 시각

   - 정수 n이 입력되면 00:00:00 ~ n:59:59 까지의 모든 시각 중에서 3이 하나라도 포함되는 모든 경우의 수를 구하는 프로그램을 구하라.

   - 입력 조건 : 첫째 줄에 정수n이 입력된다 (0<=n<=23)
   - 출력 조건 : 모든 경우의 수를 출력

   이 문제는 모든 시각의 경우를 계산해서 풀 수 있는 문제이다.
   전체 경우의 수가 24 *60 *60 이므로 86,400 가지가 된다.
   이는 파이썬의 문자열 연산을 이용해서 계산을 해도 충분히 시간 내에 풀 수 있는 문제이다. (100,000 보다 적기 때문에)
   따라서 완전 탐색 유형으로 풀 수 있다. 완전 탐색은 비효율적인 알고리즘이라서 전체 데이터의 개수가 100만 개 이하일 때 사용하면 적절하다.
   시, 분, 초 각각에 들어가는 경우의 수를 계산하는 3중 반복문을 사용해서 풀어주면 된다.

3. 왕실의 나이트

   - 8\*8 좌표 평면 위에 나이트가 있다. 나이트는 L자 형태로만 이동할 수 있고, 정원 밖으로는 나갈 수 없다. 나이트는 특정한 위치에서 2가지 경우로 이동할 수 있다.

     1. 수평으로 두 칸 이동한 뒤에 수직으로 한 칸 이동하기
     2. 수직으로 두 칸 이동한 뒤에 수평으로 한 칸 이동하기

     왕실의 정원 위치를 표현할 때, 행 위치는 1~8로 열 위치는 a~h로 표현한다.

   - 입력 조건 : 첫째 줄에 현재 나이트가 위치한 곳의 좌표를 두 문자로 구성된 문자열 입력
   - 출력 조건 : 첫째 줄에 나이트가 이동할 수 있는 경우의 수를 출력한다.

     4-1 상하좌우 문제와 유사하다. 나이트의 이동 경로를 하나씩 확인해서 이동하면 된다. 단 8\*8 좌표 평면위에서 벗어나지 않도록 검사해야 한다.
     이를 [(-2,-1),(-1,-2).....] 등 배열로 만들어서 쉽게 처리할 수 있도록 한다. 이를 일일히 반복문으로 처리하도록 한다.

4. 게임 개발

   - 게임 캐릭터가 맵 안에서 움직이는 시스템을 개발 중이다. 맵은 1*1 크기의 정사각형으로 이뤄진 n * m 크기의 직사각형인 맵이다. 각각의 칸은 육지 또는 바다로 구성되어 있다. 육지는 캐릭터가 이동할 수 있는 곳이고, 바다는 캐릭터가 이동할 수 없는 지역이다. 캐릭터는 동서남북 중 한 곳으로 이동할 수 있다.
     맵의 좌표를 표현하는 방법은 (a,b) 로 표현한다. a는 북쪽으로 떨어진 칸의 개수, b는 서쪽으로 떨어진 칸의 개수이다. 캐릭터가 움직이는 메뉴얼은 다음과 같다.

   1. 현재 위치에서 현재 방향을 기준으로 왼쪽(반시계) 방향부터 차례대로 갈 곳을 정한다.
   2. 캐릭터의 왼쪽에 가보지 않은 칸이 존재한다면, 왼쪽으로 회전한 뒤 왼쪽으로 한 칸 전진한다. 왼쪽 방향에 가보지 않은 칸이 없다면, 왼쪽으로 회전만 수행하고, 1단계로 돌아간다.
   3. 네 방향으로 모두 가본 칸이거나 바다로 되어 있는 칸인 경우에는, 바라보는 방향을 유지한 채로 한 칸 뒤로 1단계로 돌아간다. 단 뒤쪽 방향이 바다인 칸이라서 뒤로 갈 수 없는 경우에는 움직임을 멈춘다.

   이 때, 움직임이 종료되면 캐릭터가 움직임이 종료될 때까지 방문한 칸의 수를 출력하게 된다.

   - 입력 조건 : n,m을 공백으로 구분해 입력, 캐릭터가 현재 위치한 좌표 a,b와 바라보는 방향 d를 각각 공백으로 구분 (d는 0,1,2,3 으로 표현하고 각각 북,동,남,서), 맵이 육지인지 바다인지 정보를 입력, 데이터는 북에서 남으로, 서에서 동으로 순서대로 주어진다. 0: 육지 1: 바다
   - 출력 조건 : 이동을 마친 후 캐릭터가 방문한 칸의 수를 출력

   시뮬레이션 문제이다. 일단 방향을 설정해서 이동하는 유형이다. dx,dy 리스트를 만들어 방향을 정하는 것이 효과적이다. ex 북쪽으로 이동하기 위해 dx[0],dy[0]을 더한다. 이를 반복문으로 처리한다.
