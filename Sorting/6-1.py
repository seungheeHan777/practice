# 선택 정렬 (Selection Sort)

# 선택 정렬은 n개의 데이터가 있을 때,
# n-1번의 비교를 거쳐서 찾아낸 가장 작은 수를 맨 앞으로 보낸다.
# 이 과정을 n-1 번을 반복해서 데이터를 정렬하는 것이다.
# 따라서 (n-1)+(n-2)+...(n-i)+...2+1=(n-1)*n/2 라는 연산 횟수가 나온다.
# 이를 시간 복잡도로 표현하면 O(n^2) 이다.

example=[7,5,9,0,3,1,6,2,4,8]
def selection_sort(array):
    # 선택 정렬 (Selection Sort)

# 선택 정렬은 n개의 데이터가 있을 때,
# n-1번의 비교를 거쳐서 찾아낸 가장 작은 수를 맨 앞으로 보낸다.
# 이 과정을 n-1 번을 반복해서 데이터를 정렬하는 것이다.
# 따라서 (n-1)+(n-2)+...(n-i)+...2+1=(n-1)*n/2 라는 연산 횟수가 나온다.
# 이를 시간 복잡도로 표현하면 O(n^2) 이다.

    for i in range(len(array)):
        min_index = i
        for j in range(i+1,len(array)):
            if array[min_index]> array[j]:
                min_index = j
        array[i],array[min_index] =array[min_index],array[i] # 스와프
    print("selection sort")
    print(array)

# 삽입 정렬 (Insertion Sort)

# 삽입 정렬은 선택 정렬에 비해 구현 난이도가 높지만 훨씬 더 효율적인 알고리즘이다.
# 특히 삽입 정렬은 필요할 떄만 위치를 바꾸므로 데이터가 거의 정렬되어 있을 때 효율적이다.
# 선택 정렬은 현재 데이터의 상태와 상관없이 무조건 모든 원소를 비교하고 위치를 바꾸지만 삽입 정렬은 그렇지 않다.
# 삽입 정렬은 특정 데이터를 적절한 위치에 삽입한다는 의미에서 삽입 정렬이라고 한다.
# 더불어 삽입 정렬은 특정 데이터가 적절한 위치에 들어가기 전에 그 앞까지의 데이터는 이미 정렬되었다고 가정한다.
# 정렬되어 있는 데이터 리스트에서 적절한 위치를 찾은 뒤에, 그 위치에 삽입된다는 점이 특징이다.
# 삽입 정렬의 시간 복잡도는 O(n^2) 이다.
# 선택 정렬과 마찬가지로 반복문이 2번 중첩되어 사용되었다.
# 실제 테스트해보면 걸리는 시간은 비슷하지만,
# 현재 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작한다는 점이다.
# 최선의 경우 O(N)의 시간 복잡도를 가진다. 따라서 거의 정렬된 데이터를 푸는 경우라면 삽입 정렬을 이용하는 것이 효과적이다.

def insertion_sort(array):
    # 삽입 정렬 (Insertion Sort)

# 삽입 정렬은 선택 정렬에 비해 구현 난이도가 높지만 훨씬 더 효율적인 알고리즘이다.
# 특히 삽입 정렬은 필요할 떄만 위치를 바꾸므로 데이터가 거의 정렬되어 있을 때 효율적이다.
# 선택 정렬은 현재 데이터의 상태와 상관없이 무조건 모든 원소를 비교하고 위치를 바꾸지만 삽입 정렬은 그렇지 않다.
# 삽입 정렬은 특정 데이터를 적절한 위치에 삽입한다는 의미에서 삽입 정렬이라고 한다.
# 더불어 삽입 정렬은 특정 데이터가 적절한 위치에 들어가기 전에 그 앞까지의 데이터는 이미 정렬되었다고 가정한다.
# 정렬되어 있는 데이터 리스트에서 적절한 위치를 찾은 뒤에, 그 위치에 삽입된다는 점이 특징이다.
# 삽입 정렬의 시간 복잡도는 O(n^2) 이다.
# 선택 정렬과 마찬가지로 반복문이 2번 중첩되어 사용되었다.
# 실제 테스트해보면 걸리는 시간은 비슷하지만,
# 현재 리스트의 데이터가 거의 정렬되어 있는 상태라면 매우 빠르게 동작한다는 점이다.
# 최선의 경우 O(N)의 시간 복잡도를 가진다. 따라서 거의 정렬된 데이터를 푸는 경우라면 삽입 정렬을 이용하는 것이 효과적이다.
    for i in range(1,len(array)):
        for j in range(i,0,-1): # i 부터 1까지 감소하며 반복
            if array[j]<array[j-1]: # 한 칸씩 왼쪽으로 이동
                array[j],array[j-1] = array[j-1],array[j]
            else: # 자기보다 작은 데이터를 만나면 멈춤
                break
    print(array)

insertion_sort(example)

# 퀵 정렬 (Quick Sort)

# 퀵 정렬은 정렬 알고리즘 중 가장 많이 사용되는 알고리즘이다.
# 퀵 정렬과 비교해 빠른 알고리즘은 병합 정렬 알고리즘이 있다. 이 두 알고리즘은 정렬 라이브러리의 근간이 되는 알고리즘이다.
# 퀵 정렬은 기준 데이터(Pivot)를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾸는 것이다. 